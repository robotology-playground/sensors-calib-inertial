%% Comparing the eccentrity of several "grid" dataset measured on the iCub Robot
% This script take dataset in the "grid" format (generated by
% reachRandomJointPositions [1] module) on the iCub robot and compare 
% the eccentrity of the force measurement. In theory the "grid" movement
% is slowly (so the only thing that matters is gravity) moving the legs,
% while the robot is fixed on the pole (so the only external force are 
% on the root_link). In theory then the measured force should be equal 
% to m*g , where g \in R^3 is the gravity expressed in the sensor frame. 
% Hence the measured force should lie on a sphere (eccentrities 0,0) in
% theory. However imperfect sensor can have a different eccentricities (
% but in general they remain linear, so the sphere become an ellipsoid).
% For more on the theory behind this script, check [2].
% [1] : https://github.com/robotology/codyco-modules/tree/master/src/misc/reachRandomJointPositions
% [2] : Traversaro, Silvio, Daniele Pucci, and Francesco Nori. 
%       "In situ calibration of six-axis force-torque sensors using accelerometer measurements."
%       Robotics and Automation (ICRA), 2015 IEEE International Conference on. IEEE, 2015.

%% clear all variables and close all previous figures
clear
close all
clc

%% Main interface parameters ==============================================

% 'matFile' or 'dumpFile' mode
loadSource = 'dumpFile';

% model and data capture file
modelPath = '../models/iCubGenova05/iCubFull.urdf';
dataPath  = '../../data/calibration/dumper/iCubGenova05_#3/';
dataSetNb = '';

% The main single data bucket of (timeStop-timeStart)/10ms samples is sub-sampled to
% 'subSamplingSize' samples. A subset of 'subSamplingSize*subsetVec_size_frac' is
% then selected for running the ellipsoid fitting.
% The subset size = 1/number_of_subset_init of the total data set size
number_of_subset_init = 1;
subsetVec_size_frac = 1/number_of_subset_init;

% Start and end point of data samples, subsampling/filtering
timeStart = 1;  % starting time in capture data file (in seconds)
timeStop  = -1; % ending time in capture data file (in seconds). If -1, use the end time from log
subSamplingSize = 1000; % number of samples after sub-sampling the raw data

% define the limb from which we will calibrate all the sensors.
% Activate all the sensors of that limb.
jointsToCalibrate.parts = {'left_leg'};

%%=========================================================================

%% set init parameters
%
run jointsNsensorsDefinitions;

%% Parsing configuration
%
switch loadSource
    case 'matFile'
        load './data/data.mat';
    case 'dumpFile'
        % build sensor data parser ('inputFilePath',nbSamples,tInit,tEnd,plot--true/false)
        data = SensorsData(dataPath,dataSetNb,subSamplingSize,timeStart,timeStop,false);
        
        for part = 1 : length(jointsToCalibrate.parts)
            % Number of sensors for current part are:
            nrOfMTBAccs = length(mtbSensorLink_list{part});
            
            % add mtx sensors (MTB or MTI-imu)
            data.addMTXsensToData(jointsToCalibrate.parts{part}, 1:nrOfMTBAccs, ...
                mtbSensorCodes_list{part}, mtbSensorLink_list{part}, ...
                mtbSensorAct_list{part}, ...
                mtxSensorType_list{part},true);
        end
        
        % Load data from the file and parse it
        data.loadData();
        
        % Save data in a Matlab file for faster access in further runs
        %save('./data/data.mat','data');
    otherwise
        disp('Unknown data source !!')
end

%% build input data for ellipsoid fitting
%

% Select the data subset to use on ellipsoid fitting
subsetVec_size = round(data.nSamples*subsetVec_size_frac);
subsetVec_idx = round(linspace(1,data.nSamples,subsetVec_size));

% Go through 'data.frames', and get sensor measurements :
sensorsIdxListFile = [];
for frame = 1:length(data.frames)
    switch data.type{frame}
        case {'inertialMTB','inertialMTI'}
            sensorsIdxListFile = [sensorsIdxListFile frame];
        otherwise
    end
end

% get measurement table ys_xxx_acc [3xnSamples] from captured data,
sensMeasCell = cell(1,length(sensorsIdxListFile));
for acc_i = 1:length(sensorsIdxListFile)
    ys = ['ys_' data.labels{sensorsIdxListFile(acc_i)}];
    eval(['sensMeas = data.parsedParams.' ys '(:,subsetVec_idx);']);
    sensMeasCell{1,acc_i} = sensMeas';
end


%%========================================== CALIBRATION ==========================================
%
%                          ellipsoid fitting and distance to ellipsoid
%

ellipsoid_p = cell(1,length(sensorsIdxListFile)); % implicit parameters
calib = cell(1,length(sensorsIdxListFile)); % explicit parameters
ellipsoid_e = cell(1,length(sensorsIdxListFile)); % least squares error
ellipsoid_d = cell(1,length(sensorsIdxListFile)); % distance to surface

for acc_i = 1:11 %1:length(sensorsIdxListFile)
    [ellipsoid_p{acc_i},ellipsoid_e{acc_i},ellipsoid_d{acc_i}] = ellipsoidfit( ...
        sensMeasCell{1,acc_i}(:,1), ...
        sensMeasCell{1,acc_i}(:,2), ...
        sensMeasCell{1,acc_i}(:,3));
    [calib{acc_i}.centre,calib{acc_i}.radii,calib{acc_i}.quat,calib{acc_i}.R] = ...
        ellipsoid_im2ex(ellipsoid_p{1,acc_i}); % convert implicit to explicit
end

% Save all for further eventual use
%save './data/main.mat';

% Save calibration
calibratedFrames = data.frames(1,sensorsIdxListFile);
%save(['./data/' jointsToCalibrate.parts{1} '_calibration'],'calibratedFrames','calib');


%%========================================== CALIBRATION EVALUATION ===============================
%

%% clear all variables and close all previous figures
clear
close all
clc

load './data/main.mat';

%% Notes:
%  'ellipsoid_distance' uses 'ellipsoidfit_residuals'

% iteration list
accIter = 9 %1:length(sensorsIdxListFile);

%% distance to a centered sphere (R=9.81) before calibration
for acc_i = accIter
    [pVec,dVec,dOrient,d] = ellipsoid_proj_distance_fromExp(...
                                                            sensMeasCell{1,acc_i}(:,1),...
                                                            sensMeasCell{1,acc_i}(:,2),...
                                                            sensMeasCell{1,acc_i}(:,3),...
                                                            [0 0 0]',[9.8 9.8 9.8]',eye(3,3));
end
%distr of signed distances
figure('Name','distance to a centered sphere (R=9.81) before calibration');
histogram(dOrient/max(d+0.001),200);
xlabel('Oriented distance to surface','Fontsize',12);
ylabel('Normalized number of occurence','Fontsize',12);

fprintf(['distribution of distances to a centered sphere\n'...
    'mean:%d\n'...
    'standard deviation:%d\n'],mean(dOrient,1),std(dOrient,1,1));

%% distance to offseted sphere & comparison
for acc_i = accIter
    [pVec,dVec,dOrient,d] = ellipsoid_proj_distance_fromExp(...
                                                            sensMeasCell{1,acc_i}(:,1),...
                                                            sensMeasCell{1,acc_i}(:,2),...
                                                            sensMeasCell{1,acc_i}(:,3),...
                                                            calib{acc_i}.centre,[9.8 9.8 9.8]',eye(3,3));
end
%distr of signed distances
figure('Name','distance to the offseted sphere');
histogram(dOrient/max(d+0.001),200);
xlabel('Oriented distance to surface','Fontsize',12);
ylabel('Normalized number of occurence','Fontsize',12);

fprintf(['distribution of distances to a centered sphere\n'...
    'mean:%d\n'...
    'standard deviation:%d\n'],mean(dOrient,1),std(dOrient,1,1));

%% distance to non rotated ellipsoid & comparison
for acc_i = accIter
    [pVec,dVec,dOrient,d] = ellipsoid_proj_distance_fromExp(...
                                                            sensMeasCell{1,acc_i}(:,1),...
                                                            sensMeasCell{1,acc_i}(:,2),...
                                                            sensMeasCell{1,acc_i}(:,3),...
                                                            calib{acc_i}.centre,calib{acc_i}.radii,eye(3,3));
end
%distr of signed distances
figure('Name','distance to offseted, non rotated ellipsoid');
histogram(dOrient/max(d+0.001),200);
xlabel('Oriented distance to surface','Fontsize',12);
ylabel('Normalized number of occurence','Fontsize',12);

fprintf(['distribution of distances to a centered sphere\n'...
    'mean:%d\n'...
    'standard deviation:%d\n'],mean(dOrient,1),std(dOrient,1,1));

%% distance to rotated final ellipsoid & comparison
for acc_i = accIter
    [pVec,dVec,dOrient,d] = ellipsoid_proj_distance_fromExp(...
                                                            sensMeasCell{1,acc_i}(:,1),...
                                                            sensMeasCell{1,acc_i}(:,2),...
                                                            sensMeasCell{1,acc_i}(:,3),...
                                                            calib{acc_i}.centre,calib{acc_i}.radii,calib{acc_i}.R);
end
%distr of signed distances
figure('Name','distance to offseted, rotated final ellipsoid');
histogram(dOrient/max(d+0.001),200);
xlabel('Oriented distance to surface','Fontsize',12);
ylabel('Normalized number of occurence','Fontsize',12);

fprintf(['distribution of distances to a centered sphere\n'...
    'mean:%d\n'...
    'standard deviation:%d\n'],mean(dOrient,1),std(dOrient,1,1));

%% plot fitting
for acc_i = 9 %1:length(sensorsIdxListFile)
    [centre,radii,quat,R]=ellipsoid_im2ex(ellipsoid_p{1,acc_i}); % convert implicit to explicit
    [xx,yy,zz]=ellipsoid(centre(1),centre(2),centre(3),radii(1),radii(2),radii(3),100); % generate ellipse points without rotation
    vec=[xx(:),yy(:),zz(:)]; % xx(i,j),yy(i,j),zz(i,j) is a point on the ellipse. a row of zz is an iso-z
    vec=vec-repmat(centre',size(xx(:)),1); % remove offset before rotating
    vecRotated=(R*vec')'+repmat(centre',size(xx(:)),1); % rotate ellipse
    % Plot
    figure('Name', 'Fitting ellipsoid for MTB sensor');
    title(['Fitting ellipsoid for MTB sensor ' acc_i]','Fontsize',16,'FontWeight','bold');
    surf(reshape(vecRotated(:,1),101,101),reshape(vecRotated(:,2),101,101),reshape(vecRotated(:,3),101,101)); % plot
    axis equal;
    grid off;
    xlabel('x','Fontsize',12);
    ylabel('y','Fontsize',12);
    zlabel('z','Fontsize',12);
    
    figure('Name', 'Fitting ellipsoid for MTB sensor (plot from quadfit)');
    hold on;
    plot_ellipsoid(centre(1),centre(2),centre(3),radii(1),radii(2),radii(3),R,'AxesColor','black');
    scatter3(sensMeasCell{1,acc_i}(:,1),sensMeasCell{1,acc_i}(:,2),sensMeasCell{1,acc_i}(:,3));
    %title(['Fitting ellipsoid for MTB sensor ' acc_i]','Fontsize',16,'FontWeight','bold');
    axis equal;
    xlabel('x','Fontsize',12);
    ylabel('y','Fontsize',12);
    zlabel('z','Fontsize',12);
end

%plot_ellipsoid()

%ellipsoidfit_residuals
%ellipsoid_distance
